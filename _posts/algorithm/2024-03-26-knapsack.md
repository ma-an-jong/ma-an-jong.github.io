---
title: "[Algorithm] 배낭문제(Knapsack)"
excerpt: "배낭 짐싸기 문제에 대하여 알아봅시다."
categories:
    - Algorithm
tags:
    - [Algorithm]
use_math: true

toc: true
toc_sticky: true
toc_label: "목차"
toc_icon: "sticky-note"

date: 2024-03-26
last_modified_at: 2024-03-26
---

# 배낭 짐싸기

배낭은 담을 수 있는 물건의 총 무게(W)가 정해져있다.

창고에는 N개의 물건이 있고 각 물건에는 무게와 값이 정해져 있다.

배낭이 수용할 수 있는 무게를 초과하지 않으면서, 값이 최대가 되는 물건을 담아야 한다.

### Knapsack의 정형적 정의

- S = {item1, item2, item3 …..}  물건들의 집합
- w(i) = i번째 item의 무게, p(i) = i번째 item의 값, W = 배낭이 수용 가능한 총 무게 일때,

$\sum_{item(i) \in A} w(i) <= W$ 를 만족하면서

$\sum_{item(i) \in A} P(i)$가 최대가 되도록하는 $A \subseteq S$ 를 결정하는 문제로 정의된다.

## 0-1 knapsack

배낭에 물건을 통째로 담아야 하는 경우로 물건을 쪼갤수 없는 경우이다.

### 완전 탐색 방법

- 완전 탐색으로 물건 집합의 모든 부분집합을 구한다.
- 부분 집합의 총 무게가 W이하이고 비용이 가장 큰 집합을 구한다.
- 물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가한다. O(2^N)

### 탐욕적 방법1

- 값이 비싼 물건부터 채운다.
- 탐욕적 방법의 결과가 최적이 아닐 경우가 있다. (ex) 단위 비용이 너무 작은 경우, 빈공간이 커지는 경우)

### 탐욕적 방법2

- 무게가 가벼운 물건부터 채운다.
- 최적이 아닐 수 있다. (ex) 단위 비용이 너무 작은 경우, 빈공간이 커지는 경우)

### 탐욕적 방법3

- 단위 무게당 값이 높은 물건을 채운다.
- 최적이 아닐 수 있다.

### 그리디가 0-1 knapsack에서 온전한 솔루션이 될 수 없는 이유

> **it does not consider the possibility of excluding certain items to achieve a better overall solution**
> 

그리디 알고리즘은 최적화 용도로 많이 사용된다. 

그리디는 전체 문제의 최적화를 위해서 부분 문제의 최적해를 구해야한다. 

이때, 단위 무게당 비용, 단위 비용당 무게를 통해서 가방에 물건을 넣을 수 있다.

여기서 핵심은 그리디 알고리즘은 항상 포함된 item에 대한 더 나은(최적의) 비용만 계산한다는 점이다. 

excluding item은 고려하지 않고, 자신이 선택한 item들에 의해서 가능성만 고려하기 때문에 잠재적이거나 결정이 뒤바꿀 수 있는 item에 대한 가능성을 고려하지 않아서 전역으로 최적해를 구할 수 없다.

| Item | Weight | Value | value per weight |
| --- | --- | --- | --- |
| A | 3 | 1.8 | 0.6 |
| B | 2 | 1 | 0.5 |
| C | 2 | 1 | 0.5 |

그리디 알고리즘은 처음으로 A를 선택할 수 밖에 없다. 그러나 잔여 용량이 충분하지 않아 다른 물건이 들어갈 수 없어 B,C가 들어가는 최적해보다 크기가 작다.

### 해결 방법

- 완전 탐색을 이용하거나 다이나믹 프로그래밍을 사용한다.

가방의 무게를 include + exclude 두 부분으로 나눈다. include에 들어갈 수 있는 최대 비용과 exclude에 들어갈 수 있는 최대 비용의 합을 통해서 가방에 담을 수 있는 최대 비용을 구할 수 있다.

f(i, W)를 물건 i까지 W의 범위를 넘기지 않도록 만드는 최적의 가치라고 정의하자.

물건 i가 W를 넘긴다면 가방의 무게를 유지하여 f(i+1,W)를 탐색하고

그렇지 않다면 f(i+1, W- w(i))를 탐색한다.

매 시퀀스마다 가방에 물건을 담을지, 담지 않을지 결정하여 include와 exclude를 나누어 계산 가능하다. 따라서 max 는 f(i-1, W - w(i)) + P(i) 와 f(i-1,W) 중 더 큰 값이다.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/knapsack/recurrence_relation.png">
</div>

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/knapsack/table.png">
</div>

### 함축적 순서

배낭 문제의 부분 문제간의 함축적 순서는 다음과 같다.

2개의 부분 문제가 계산되어 있어야 그 다음 해를 구할 수 있다.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/knapsack/order.png">
</div>

## Fractional knapsack

물건을 부분적으로 담는 것이 허용되며 즉, 물건을 쪼갤 수 있는 경우이다.

### 탐욕적 방법

- 단위 무게당 값이 높은 물건을 채운다.
- 언제나 최적해를 찾을 수 있다. 물건을 단위 무게로 쪼갤 수 있기 때문이다.

## 공간 복잡도 개선

탑 다운 방식의 반복문을 이용한 dp를 하게 된다면, 1차원 배열로 문제를 해결할 수 있다.

i번째 물건까지 탐색했을때, 무게 W를 채울 수 있는 최대 비용을 모두 탐색, 저장하며 최적해를 계산하였다. 그런데, 점화식을 잘 살펴보면 i-1번째 부분 문제만을 고려하며 최적해를 계산하고 있다. 즉 i-2번째 뒷부분은 1번만 사용하고 버려지는것이다. 

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/knapsack/sparse_table.jpg">
</div>

이를 1차원 배열로 최적화 할 수 있다. 무게 W를 채울 수 있는 무게를 계산하기 위해서 물건 i를 검사할때 초기 1차원 배열에 저장된 값은 i-1번째 최적해들이다. 

물건 i를 넣을 차례에서 W - w(i)번에 저장된 값은 i-1번째 물건까지 넣었을 때 해당 무게의 최적해이다. 따라서 2차원 배열을 이용한 경우와 동일한 최적해를 구할 수 있다.

## 물건의 개수가 무제한이라면?

- 물건 개수가 무제한이기 때문에 바텀 업 방식으로 dp를 한다.

0에서 무게가 w인 물건을 넣으면 무게 w가 되고 다시 물건을 넣어서 2w를 만들 수 있다.

따라서 0부터 물건을 넣는것을 계산하여 최적해를 구하면 물건의 개수를 고려할 수 있다.