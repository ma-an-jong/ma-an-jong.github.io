---
title: "[Algorithm] LIS/LCS"
excerpt: "최장 길이 증가 부분 수열, 최장 길이 공통 부분 수열에 대하여 알아봅시다."
categories:
    - Algorithm
tags:
    - [Algorithm]
use_math: true

toc: true
toc_sticky: true
toc_label: "목차"
toc_icon: "sticky-note"

date: 2024-03-27
last_modified_at: 2024-03-27
---

# 최장 증가 부분수열(Longest Increasing Subsequence)

어떤 수열이 왼쪽에서 오른쪽으로 나열되어 있으면 배열 순서를 유지하며 크기가 점진적으로 증가하는 가장 긴 부분 수열의 **길이를** 구하는 문제

## Brute-force 접근 방법

수열의 모든 부분 집합을 구하여 그 부분 집합이 증가 수열인지 판별한다.

증가 수열 중 가장 긴 길이의 수열을 출력한다.

부분 수열의 길이가 긴 것부터 조사하는 것이 유리하다.

$O(2N)$ , 지수시간 복잡도를 가짐

## DP 접근 방법

LIS[i] : i까지의 최장 부분 수열의 길이

- Lis[i] 가 ai를 포함하지 않는다면 Lis[i] = LIS[i-1]
- LIS[i] 가 ai를 포함한다면 LIS[i] = ?

### DP

증가 수열 관계인 aj < ai를 찾는다

j값을 알 수 없으므로 모두 검색하야 한다.

그 중 최댓값을 찾아 1을 증가시켜 LIS(i)에 저장한다

LIS(i) = 1 + max LIS[j]

O(n^2)의 시간이 소모된다.

```cpp
for(int i = 0; i < N ; i++){
	for(int j = 0; j < i;j++) {
		if(a[i] < a[j] and 1 + LIS[j] > LIS[i])
			LIS[i] = LIS[j] + 1;
	}
}
```

### 이진 탐색을 이용한 방법

C[k] : 길이 k의 증가 수열에 대하여 가장 작은 값을 C[k]에 저장

각 위치에서 C를 갱신하기 위해 이진 검색을 수행

O(nlogn)시간이 소모된다.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/lis/binary_search_lis.png">
</div>

그러나 C배열의 최종 상태가 증가하는 부분 수열의 순서와 일치하지 않기 때문에 출력하면 다른 결과나 생성된다.

## LIS 수열을 구하는 방법

LIS의 길이는 구할 수 있어도, 그 길이를 만족하는 부분 수열이 무엇인지 알 수 없었다.

심지어 LIS를 만족하는 부분 수열은 1가지가 아니라 여러개 일 수 있다.

### DP에서 구하는 방법

일반적인 DP 테이블을 역추적하는 방법으로 수열을 구할 수 있다.

aj < ai 를 만족하는 dp 테이블을 다시 반대 방향으로 탐색하면서, i번째와 j 번째가 1 + LIS[j] == LIS[i]를 만족시킨다면, j에서 i로 증가하는 수열을 만족하기 때문에 역추적이 가능하다.

### 이진 탐색에서 구하는 방법

C[i] 번째 원소가 추가될때마다 연결 리스트, 스택, 큐 등을 활용한 선형 자료구조를 배열로 만들어(이하 S) 인덱스와 함께 값을 저장한다. 

이후 S 배열 가장 뒤부터 저장된 데이터가 이전 값보다 작고 인덱스가 내림차순으로 구성된 수열을 찾는다.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/lis/lis_subsuquence.jpg">
</div>

# 최장 공통 부분 수열(Longest Common SubSequence)

주어진 모든 수열이 가지는 공통 부분 수열 중, 가장 길이가 긴 공통 부분 수열을 의미한다.  LIS와 마찬가지로, 길이를 구하는 알고리즘이다.

s1 = A**G**G**TAB**

s2 = **G**X**T**X**A**Y**B**

LCS = **GTAB**

## Brute-force 접근 방법

재귀함수 lcs()를 이용하여 완전 탐색 방법으로 해를 구할 수 있다.

두 문자열의 인덱스 n과 m을 이용할 수 있다.

### n번째 문자와 m번째 문자가 같다면

n-1, m-1 번째 인덱스까지 LCS의 길이에 1을 더하여 LCS의 길이를 구할 수 있다. n-1, m-1의 LCS는 재귀 함수를 호출하여 계산할 수 있다.

### n번째 문자와 m번째 문자가 서로 다르다면

n-1,m의 LCS와 n,m-1의 LCS 중 길이가 더 긴 것을 선택한다. 마찬가지로 n01,m 과 n,m-1의 LCS도 재귀 함수를 통해서 계산할 수 있다.

### Code

```jsx
int lcs(String X, String Y, int m, int n) 
{ 
    if (m == 0 || n == 0) 
        return 0; 
        
    if (X.charAt(m - 1) == Y.charAt(n - 1)) 
        return 1 + lcs(X, Y, m - 1, n - 1); 

    return max(lcs(X, Y, m, n - 1),lcs(X, Y, m - 1, n)); 
} 
```

### 시간 복잡도

재귀 호출로 인해서 $2^{(N+M)}$이다.

## DP 접근 방법(Top-Down)

### Memoization

위에서 재귀 함수의 결과를 dp 테이블에 memoization을 하여 중복 계산을 줄이는 방법이다.

LCS는 부분 문제 구조와 최적 문제 구조를 모두 만족하기 때문에 부분 문제로 나누어 풀이할 수 있기 때문이다.

### Code

```jsx
int lcs(String X, String Y, int m, int n, int[][] dp) 
{ 
    if (m == 0 || n == 0) 
        return 0; 

    if (dp[m][n] != -1) 
        return dp[m][n]; 

    if (X.charAt(m - 1) == Y.charAt(n - 1)) { 
        dp[m][n] = 1 + lcs(X, Y, m - 1, n - 1, dp); 
        return dp[m][n]; 
    } 

    dp[m][n] = Math.max(lcs(X, Y, m, n - 1, dp), lcs(X, Y, m - 1, n, dp)); 
    return dp[m][n]; 
} 
```

### 시간 복잡도

memoization을 통해서 중복 부분을 dp테이블에 저장하여 재사용하기 때문에 $O(NM)$이다.

## DP 접근 방법(Bottom-Up)

### Tabulation

하향식으로 dp 테이블을 채워나가는 방법이다.

2차원 배열 lcs[][] 를 만들고 i,j 인덱스까지 lcs를 계산한다.

i, j 의 LCS는 지금까지 본 방법과 비슷하게 i,j의 문자가 서로 일치하면 i-1, j-1의 lcs에 + 1을 하고, 그렇지 않다면 i-1,j와 i,j-1의 lcs 중 더 긴 것을 선택한다. 이는 2중 for문을 통해서 계산할 수있다.

### 시뮬레이션

인덱스가 0인 경우 lcs는 모두 0이기 때문에 0으로 초기화하여 계산한다. 이는 Out Of Index의 처리도 간편하게 할 수 있다.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/lis/lcs_table_1.jpg">
</div>

1,5번 문자가 서로 동일하기 때문에 0,4의 lcs에 +1을 한다. 이 동작을 N*M번 반복하면 아래와 같이 테이블이 채워진다.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/lis/lcs_table_2.jpg">
</div>

두 문자열의 LCS는 N,M에 저장되어있다.

### Code

```jsx
int lcs(String X, String Y, int m, int n) 
{ 
    int L[][] = new int[m + 1][n + 1]; 

    for (int i = 1; i <= m; i++) { 
        for (int j = 1; j <= n; j++) { 
            if (X.charAt(i - 1) == Y.charAt(j - 1)) 
                L[i][j] = L[i - 1][j - 1] + 1; 
            else
                L[i][j] = max(L[i - 1][j], L[i][j - 1]); 
        } 
    } 
    return L[m][n]; 
} 
```

### 시간 복잡도

dp테이블을 모두 채우는데 걸리는 시간인 $O(NM)$이다. 함수 호출 오버헤드가 없기 때문에 memoization 방식보다 조금 더 효율적이다.