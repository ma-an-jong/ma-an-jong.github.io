---
title: "[Algorithm] 비트마스킹"
excerpt: "비트를 활용하여 조합 문제를 풀어보자."
categories:
    - Algorithm
tags:
    - [Algorithm]

toc: true
toc_sticky: true
toc_label: "목차"
toc_icon: "sticky-note"

date: 2024-01-24
last_modified_at: 2024-01-24
---

## 비트(bit)

컴퓨터에서 자료를 표현하기 위해 비트(bit)를 사용한다. 1 bit는 0 또는 1의 값을 갖고 있다.

## 비트 연산자

### 비트 연산자 종류

| 비트 연산자 |  | a = 1010 , b = 0100 |  |
| --- | --- | --- | --- |
| & | AND | a & b = 0000 | AND |
| \| | OR | a | b = 1110 | OR |
| ^ | XOR | a ^ b = 1110 | 같으면 0 다르면 1 |
| ~ | NOT | ~a = 0101 | 반전 |
| << | 왼쪽 SHIFT | a << n = a * 2^n | 왼쪽 이동 |
| >> | 오른쪽 SHIFT | a >> n = a * 2^(-n) | 오른쪽 이동 |

### 비트 연산 우선순위

사칙 연산(+,-,*,/)은 비교(==,> 등), 논리 연산자( \|\| , &&)보다 우선순위가 높다.

비트 연산은 논리 연산보다 우선순위가 높고 비교 연산보다 낮다. 

| 우선 순위 | 연산 | 연산자 |
| --- | --- | --- |
| 1 | 사칙 연산 | +, - , * , / |
| 2 | 비교 연산 | == , > , ≥ |
| 3 | 비트 연산 | &, | , ~ , ^ , >> |
| 4 | 논리 연산 | && , || |

```java
if(x & y == 0) // if(x & (y == 0))과 같다.
```

## 비트 연산 기본

### 1 << n

- 2^n 값을 갖는다
- 원소가 n개일 경우 모든 부분집합의 수를 의미한다.
- 모든 부분 집합 계산
    - 각 비트가 집합에 포함되면 1, 포함되지 않으면 0으로 0부터 2^n  -1 까지 수를 검사하면 모든 부분집합을 찾을 수 있다.

### i & ( 1<< j)

- i의 j번째 비트가 1인지 0인지 확인한다.
- 이를 활용하여 j번째 원소가 집합에 포함되었는지 확인할 수 있다.

### Bit를 이용한 부분 집합 생성

- 원소 수에 해당하는 N개의 비트를 이용한다.
- n번째 비트 값이 1이면 n번째 원소가 포함되었음을 의미한다.

| 10진수 | 이진수 | {A,B,C,D} |
| --- | --- | --- |
| 0 | 0000 | {} |
| 1 | 0001 | {A} |
| 2 | 0010 | {B} |
| 3 | 0011 | {A,B} |
| 4 | 0100 | {C} |
| 5 | 0101 | {A,C} |
| 6 | 0110 | {B,C} |
| 7 | 0111 | {A,B,C} |
| 8 | 1000 | {D} |
| 9 | 1001 | {A,D} |
| 10 | 1010 | {B,D} |
| 11 | 1011 | {A,B,D} |
| 12 | 1100 | {C,D} |
| 13 | 1101 | {A,C,D} |
| 14 | 1110 | {B,C,D} |
| 15 | 1111 | {A,B,C,D} |

## 비트 연산 응용

### AND(&), OR(|)

- 비트 집한 두 개를 AND하면 교집합, OR하면 합집합을 구할 수 있다.

### XOR(^)

- true/false 번갈아 바꾸는 스위치를 구현할 수 있다.
- 어떤 수에서 몇 개의 bit를 바꿔서 대응되는 수를 구할 수 있다.
    - ASCII 코드에서 짝이 맞는 문자끼리 다른 bit를 XOR시키는 기법을 이용한 대소문자 변환 함수

```java
char toggle(char alphabet) {
	return alphabet ^ 32; //대문자는 소문자로, 소문자는 대문자로 변환한다.
}
```

- 같은 값 끼리 XOR을 하면 0이 되는 특징
    - 각 변이 x축 또는 y축에 평행한 직사각형이 존재한다. 이 직사각형의 세 꼭지점의 좌표가 주어졌을 때 남은 한 꼭지점의 좌표는 어떻게 구할까?
    
<div style="text-align: center;">
    <img src="/image/posts/algorithm/bitmasking/pos.jpg">
</div>

XOR을 사용하여 남은 한 점의 좌표는 (x1 ^ x2 ^ x3, y1 ^ y2 ^ y3)이다.

### NOT(~)

- 비트 집합에 사용하여 가지고 있지 않은 원소들을 구할 수 있다.(비트 마스킹)

### SHIFT(>>)

- 2의 거듭제곱 곱셈/나눗셈
    - 정수형을 왼쪽으로 i칸 밀거나 오른쪽으로 i칸 미는 연산은 각각 2^i를 곱하거나 2^i로 나누는 연산이다.
    - 특히 나누는 수가 2의 거듭제곱일 경우 >>가 / 연산에 비해 성능 향상을 얻을 수 있다.
    - 마찬가지로 % 연산도 나누는 수가 2의 제곱수 일 경우 &로 바꿀 수 있다.
    - 그러나, 밀고자 하는 칸의 개수가 음수일때 제대로 동작하지 않는다.

```java
// 음수일 때 제대로 동작하지 않음
static void div(int num, int x) {
    System.out.printf("%d / %d => 몫 : %d 나머지 : %d\n", num, 1 << x, num >> x, num & ((1 << x) - 1));
}

div(5,2);
div(6,2);
div(5234,4);
div(5,-2);

/**
 * 5 / 4 => 몫 : 1 나머지 : 1
 * 6 / 4 => 몫 : 1 나머지 : 2
 * 5234 / 16 => 몫 : 327 나머지 : 2
 * 5 / 1073741824 => 몫 : 0 나머지 : 5 //제대로 동작하지 않는다.
 */
```

## 비트 마스킹

각 Bit를 하나의 Flag로 활용한다면 자료 저장과 집합 표현을 쉽게 할 수 있다.

사람에 0 ~ 31 번호가 매겨져 있고, 사람 A의 친구 목록이 {0,3,6,7,10,13,28}이고 , B의 친구 목록이 {0,1,4,5,6,17,21,28} 일때 

- A,B 모두 친구인 사람은?
- A 또는 B와 친구인 사람은?

반복문을 이용해서 문제를 풀 수 도 있지만, 비트를 사용하면 “집합” 연산이 간단해진다.

친구 목록을 사람 번호로 저장하지 않고 x번재 사람이 내 친구라면 ,x 번째 비트를 1로 표시하는 방식으로 변경하면

A와 B 친구 목록을아래 처럼 비트로 나타낼 수 있다.

<div style="text-align: center;">
    <img src="/image/posts/algorithm/bitmasking/img1.png">
</div>

이렇게 비트로 친구 목록을 저장하여 앞의 두 문제를 빠르게 해결할 수 있다.

A와 B 모두 친구인 사람은 AND 연산으로 구할 수 있고 A 또는 B와 친구인 사람은 OR 연산을 이용하여 구할 수 있다.

<div style="text-align: center;">
    <img src="/image/posts/algorithm/bitmasking/img2.png">
</div>

추가적으로 X번째에 있는 사람이 친구인지 구하는 함수는 다음과 같다.

```java
// x번째 사람이 친구인지 구하는 함수
bool getX(int A, int x) {
    if(A &(1<< x)){
        return true;
    }

    return false;
}
```

X번재 사람을 친구로 추가해주는 코드는 다음과 같다.

```java
// x번째 사람을 친구로 추가하는 함수
void setX(int A, int x) {
    A |= (1<< x);
}
```

X번째 사람을 친구에서 제외하는 코드는 다음과 같다.

```java
// x번째 사람을 친구에서 제외하는 함수
void removeX(int A, int x) {
    A &= ~(1<< x);
}
```

## 데이터 압축

길이가 N인 문자열 2개를 비교하는데 O(N)의 시간이 필요하다. 만약 사용하는 문자의 가지수가 적다면 필요한 bit만 골라내서 정수형으로 압축 가능하다.

예를 들어 문자열이 알파벳 대문자로만 이루어졌다면 알파벳끼리 구분하는 데에 1이상 26이하의 값만 필요하다. 이는 5bits 만으로도 표현할 수 있다.

<div style="text-align: center;">
    <img src="/image/posts/algorithm/bitmasking/img3.png">
</div>

이렇게 압축된 정수의 대소 비교 결과는 원래 문자열의 사전순 비교 결과와 같다.

```java
long compress(char[] arr) {
    long ret = 0;
    for (int i = 0; i < arr.length; ++i) {
        ret = (ret << 5) | (arr[i] ^ 64);
    }
    return ret;
}
```