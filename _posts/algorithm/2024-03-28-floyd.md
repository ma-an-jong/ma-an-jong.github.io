---
title: "[Algorithm] 플로이드 워셜"
excerpt: "모든 쌍 최단경로를 구하는 플로이드 워셜에 대하여 알아봅시다."
categories:
    - Algorithm
tags:
    - [Algorithm]
use_math: true

toc: true
toc_sticky: true
toc_label: "목차"
toc_icon: "sticky-note"

date: 2024-03-28
last_modified_at: 2024-03-28
---

# 모든 쌍 최단 경로(플로이드-워셜)

## 문제

- 다음 각 정점 사이의 최단 경로는 얼마인가? 1에서 2까지 최단 경로는 1이며, 1에서 5까지의 최단 경로 값은 4이다. 모든 정점 사이의 최단 경로 값을 구하라.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/floyd/graph.png">
</div>


## 플로이드 워셜 특징

### 모든 쌍 최단 경로 알고리즘

다익스트라, 벨만 포드 알고리즘과는 달리, 모든 정점 쌍의 최단 경로를 구하는 알고리즘이다.

가중치 그래프에서 음이 아닌 사이클이 존재하지 않을때 최단 경로를 찾을 때 사용할 수 있다.

### 최적화 문제

주어진 문제에 대하여 하나 이상의 많은 길이 존재한다. 이 가운데 최적 해를 구하는 문제이다.

### 음수 간선

양수 간선, 음수 간선 모두 존재할때 사용 가능하다. 그러나 음수 사이클이 존재하면 안된다.

## brute-force 접근법

한 정점에서 다른 정점으로 모든 경로의 길이를 구한 뒤, 그들 중에서 최소 길이를 찾는다.

그래프가 $N$개의 정점의 완전 그래프이면 $i → j$ 로 가는 가지수는 $N-2$개이고 $j → k$로 갈 수 있는 정점의 수는 $N-3$이다. 계산하면 $(N-2)(N-3)(N-4) … = O((N-2)!)$이다.

## 다익스트라 N번

### 접근법

각 정점을 시작 정점으로 다익스트라 최단 경로 알고리즘을 $N$번 수행하면 모든 쌍 최단 경로를 구할 수 있다. 

### 시간 복잡도

인접 행렬 사용 시 $O(N^{3})$이고, 인접 그래프를 사용해도 $O(N * E * log{N})$가 된다.

완전 그래프에서 $E$는 $N^{2}$과 거의 동일하기 때문에 모든 쌍 최단 경로를 구할때는 플로이드 워셜이 더 적절할 수 있다.

## DP

### 아이디어

다이나믹 프로그래밍을 통해서 출발 정점에서 중간 정점을 지나 목적 정점까지 이동 가능한 모든 경로를 탐색한다.

1부터 N까지 정점을 갖는 그래프에서 $i → j$ 최단 경로를 $shortestPath[i][j]$라고 정의한다. 

이때, $i → j$ 경로 사이에는 어떤 중간 정점 $k$가 존재한다.

플로이드 워셜 알고리즘은 이 중간 정점 $k$가 될 수 있는 $N$개 정점을 하나씩 탐색하여 $i→ k$ 최단 경로 $shortestPath[i][k]$ 와 $k → j$ 최단 경로 $shortestPath[k][j]$ 를 구하는 부분 문제를 활용한다.

### 시뮬레이션

초기 최단 경로 테이블은 $i→j$로 바로 갈 수 있는 간선의 경로로 초기화한다. 갈 수 없는 경로는 무한대로 초기화한다.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/floyd/floyd.jpg" style = "width:50%;">
</div>

중간 경유점을 $A$로 놓고, $i → A → j$ 의 최단 경로를 구하여 최단 경로 테이블을 갱신한다. 노란색 박스가 갱신될 수 있는 최단 경로 테이블이다. 

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/floyd/floyd_a.jpg" style = "width:50%;">
</div>

중간 경유점을 $B$로 놓고, $i → B → j$ 의 최단 경로를 구하여 최단 경로 테이블을 갱신한다.

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/floyd/floyd_b.jpg" style = "width:50%;">
</div>


$C,D,E$ 순서대로 중간 경유지로 놓고 최단 경로 테이블을 갱신하면 최종적으로 모든 쌍 최단 경로를 저장하는 최단 경로 테이블이 완성된다. 

<div style="text-align: center;">
    <img src = "/image/posts/algorithm/floyd/floyd_e.jpg" style = "width:50%;">
</div>

### 코드

점 $i → j$ 의 최단 경로를 찾으려면 3중 for문을 통해서 $i → j$ 를 찾거나 $i → k → j$를 찾는다.

주의할 점은 $1$에서 $k$까지 모든 점을 반드시 경유하는 경로는 아니다. 가장 최적해만 탐색한다.

```java
for(int k = 0; k < n ; k++) //경유
  for(int i = 0; i < n; i++) //출발
    for(int j = 0; j < n; j++) //도착
      if(d[i][j] > d[i][k] + d[k][j]) {
        d[i][j] = d[i][k] + d[k][j]
      }
```

### 시간 복잡도

플로이드 워셜의 시간 복잡도는 반복문을 3번 중첩하여 $O(N^{3})$이 된다.

## 다익스트라와 차이

### 시간 복잡도

다익스트라 알고리즘의 시간 복잡도는 배열을 사용하면 $O(N * E * log{N})$ 또는 $O(N^{3})$이다. 

플로이드 알고리즘의 시간 복잡도는 $O(N^{3})$이다. 그러나 코드가 단순하다

### 음의 가중치

다익스트라 알고리즘은 그리디 알고리즘으로 음의 가중치가 존재하지 않는다고 가정한다.

그러나 플로이드 워셜은 음의 사이클만 없다면, 음의 가중치가 존재해도 좋다.

## 플로이드 워셜을 이용한 음수 사이클 판독

방향 그래프가 주어졌을때, 그래프가 음수 간선을 포함하고 있는지 여부를 확인할 수 있다.

### 아이디어

벨만포드와 비슷한 방법으로 음수 사이클을 판독할 수 있다.

블로이드 워셜은 자기 자신으로 가는 경로의 비용은 항상 0이다. 만약, 음수 사이클이 존재한다면 우자기 자신으로 가는 경로가 음수임을 확인할 수 있다.

```java
for (i = 0; i < n; i++)
  if (d[i][i] < 0)
    return true; // 음수 사이클 존재
```