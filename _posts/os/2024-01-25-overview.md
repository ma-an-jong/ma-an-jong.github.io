---
title: "[OS] Overview"
excerpt: "공룡책(Operating System Concept)의 1장 내용을 정리한 내용입니다."
categories:
    - OS
tags:
    - [OS, Interrupt]

toc: true
toc_sticky: true
toc_label: "목차"
toc_icon: "sticky-note"

date: 2024-01-25
last_modified_at: 2024-02-01
---

<style> 

#wrap {
        width: 1000px;
        display: flex;
    }

#aside {
    background-color: #efefef;
}
</style>

## 운영체제가 할 일

컴퓨터 시스템이 동작할 때 자원을 적절하게 사용할 수 있는 방법을 제공한다.

**→ 다른 프로그램이 유용한 작업을 할 수 있는 환경을 제공한다.**

### 사용자 관점

자원의 이용에는 신경을 쓰지 않고, **사용의 용이성(인터페이스)**를 위해 설계된다.

### 시스템 관점

운영체제를 **자원 할당자(resource allocator, control program)**로 볼 수 있다. 

모든 시스템은 운영체제 위에서 실행되기 때문에 운영체제의 작동 방식에 대한 지식은 효율적이고 안전한 프로그래밍에 중요하다.

<div style="text-align: center;">
    <img src = "/image/posts/os/overview/computerSystemView.png" width = "80%">
</div>

## 현대 컴퓨터 시스템의 구성

- 하나 이상의 **CPU**
- **장치 컨트롤러**
    - disk controller, USB controller 등
- 공유 메모리와 구성 요소간의 엑세스를 제공하는 **공통 버스**

<div style="text-align: center;">
    <img src = "/image/posts/os/overview/modernComputerSystem.png" width = "80%">
</div>

각 장치 컨트롤러마다 **장치 드라이버**가 존재한다. 장치 컨트롤러에 따라서 둘 이상의 장치를 연결하기도 한다.

CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다. **공유 메모리를 질서 있게 액세스하기 위해서 메모리 컨트롤러는 메모리에 대한 액세스를 동기화한다.**

### 인터럽트(Interrupts)

한 장치의 작업 과정은 다음과 같다.

**1. 입출력 작업 시작** <br>
**2. 장치 드라이버가 장치 컨트롤러의 적절한 레지스터에 값을 적재** <br>
**3. 장치 컨트롤러는 레지스터의 내용을 검사하여 수행할 작업 결정(키보드에서 문자 읽기)** <br>
**4. 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송 시작** <br>
**5. 데이터 전송 완료 → 컨트롤러는 장치 드라이버에게 작업 완료를 알림** <br>

<!-- <div style="text-align: center;">
    <img src = "/image/posts/os/overview/deviceWorking.png" width = "80%">
</div> -->

장치 드라이버는 요청 완료를 알려 운영체제의 다른 부분에 제어를 넘긴다. 그런데 **컨트롤러는 어떻게 장치 드라이버에게 작업 완료 사실을 전달할까?** 이는 <span style="color:red"> **인터럽트** </span>를 통해서 이루어진다.

**모든 하드웨어는 어느 순간이든 시스템 버스를 통해서 CPU에 신호를 보내서 인터럽트를 발생 시킬 수 있다.**

컴퓨터 시스템에는 많은 버스가 존재하지만, 그중에서도 시스템 버스는 주요 구성요소 사이의 주요 통신 경로이다.

인터럽트는 다른 많은 목적으로도 사용되며 **운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.**

CPU가 인터럽트 되면, **CPU는 하던 일을 중단하고 즉시 고정된 위치로 실행을 옮긴다.**

이 고정된 위치는 **인터럽트 발생에 적절하게 대응할 수 있는** 특정 로직을 갖고있는 서비스 루틴의 시작 주소를 가지고 있다.

이를 <span style="color:red"> **인터럽트 서비스 루틴** </span> 이라고 한다.

그리고 **인터럽트 서비스 루틴**이 실행된다. **인터럽트 서비스 루틴**의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 **재개**한다.

<div style="text-align: center;">
    <img src = "/image/posts/os/overview/interruptTimeline.png" width = "80%">
</div>

**인터럽트는 적절한 서비스 루틴으로 제어를 전달한다.** 이때 어떤 제어를 전달함에 따라서 어떤 인터럽트 서비스 루틴을 호출할건지 결정하는 직관적인 방법은 **인터럽트의 정보를 조사하는 루틴을 호출하는 방법이다.**

인터럽트 정보를 조사하는 루틴은 인터럽트 **고유의 핸들러(hanler)**를 호출한다. **그러나, 인터럽트는 매우 빈번하게 발생하기 때문에 빠르게 처리되어야 한다.**

빠른 속도를 위해서 인터럽트 루틴에 대한 포인터들의 **테이블**을 대신 사용한다. 

이 경우, 중간 루틴을 둘 필요가 없으며 **테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다.**

인터럽트가 요청되면, **인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해서 이 주소의 배열, 즉 인터럽트 벡터가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.(색인된 위치에 인터럽트 서비스 루틴이 존재한다.)**

**인터럽트 구조는 인터럽트 전 모든 정보를 저장해야 인터럽트 이후 이 정보를 복원할 수 있다.**

만약 인터럽트 서비스 루틴이 처리기의 상태를 변경할 필요(예를 들어 레지스터의 값을 변경)가 있다면, **인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장해야 하며, 복귀하기 전에 상태를 복원해야 한다.**

인터럽트 서비스가 종료되면 저장되어 있던 복귀 주소를 프로그램 카운터에 적재하여 인터럽트에 의해 중단되었던 연산이 **인터럽트가 발생되지 않았던 것처럼 다시 시작된다.**

### 인터럽트 구현

CPU 하드웨어에는 **인터럽트 요청 라인(Interrupt Request Line)**이라는 선이 존재한다. 

CPU는 컨트롤러가 인터럽트 요청 라인에 신호를 보낸것을 감지하면, 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여 **인터럽트 핸들러 루틴(Interrupt-Handler Routine)**으로 점프한다. 

점프한 위치의 인터럽트 서비스 루틴을 시작한다.

- **1. 인터럽트 처리기는 작업 중에 변경될 상태를 저장하고**
- **2.인터럽트 원인을 확인하고**
- **3.필요한 처리를 수행하고**
- **4.상태를 복원하고 return_from_interrupt 명령어를 실행하여 CPU를 인터럽트 전 실행 상태로 되돌린다.**

<div style="text-align: center;">
    <img src = "/image/posts/os/overview/interrupt.png">
</div>

요약하자면, 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 <span style="color:red">**인터럽트를 발생(raise)**</span> 시키고 CPU는 <span style="color:red">**인터럽트를 포착(catch)**</span> 하여 <span style="color:red">인**터럽트 핸들러로 디스패치(dispatch)**</span>하고 핸들러는 장치를 서비스하여 <span style="color:red">**인터럽트를 지운다(clear).**</span>


이 기본 인터럽트 기법은 장치 컨트롤러가 서비스할 준비가 될 때와 같은 비동기 이벤트에 CPU가 대응할 수 있게 한다.

### 최신 인터럽트

최신 운영체제에는 더욱 정교한 인터럽트 처리 기능이 필요하다.

1. 중요한 처리 중에 인터럽트 처리를 **연기**할 수 있어야 한다.
2. **장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.**
3. 운영체제가 **우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분**하고 **적절한 긴급도로 대응할 수 있도록** **다단계 인터럽트****가 필요하다.**

이 세가지 기능을 CPU 및 인터럽트 컨트롤러 하드웨어에서 제공한다. 

대부분의 CPU에는 2개의 **인터럽트 요청 라인**이 있다. 

- **마스킹 불가능 인터럽트(nonmaskable interrupt)**
    - 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 **예약된 인터럽트**
- **마스킹 가능(maskable interrupt)**
    - 장치 컨트롤러가 서비스를 요청하기 위해서 사용

**벡터 방식 인터럽트 기법**의 목적은 **서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위한것이다.**

**그러나 실제로는 컴퓨터에는 인터럽트 벡터의 주소 개수보다 많은 인터럽트 처리기가 존재한다.** 이 문제를 해결하는 일반적인 방법은 **인터럽트 체인**을 사용하는것이다.

**인터럽트 벡터의 각 원소를 인터럽트 핸들러 리스트의 헤드를 가리키는 구조로 만든다.**

인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출된다. 

이러한 구조는 큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치하는 비효율성의 절충안이다.

Intel 프로세서의 인터럽트 벡터 설계는 다음과 같다.

- 마스크 불가능한 0 ~ 31까지 이벤트는 다양한 오류를 알리는데 사용한다.
- 마스크 가능한 32 ~ 255까지 이벤트는 장치가 생성한 인터럽트 같은 나머지 인터럽트를 처리하기 위해 사용한다.

**또한, 인터럽트 기법은 우선순위 레벨을 구현한다.** CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가 높은 인터럽트가 실행을 먼저 선점할 수 있다.

### 요약

인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해서 사용된다. 물론 다른 용도로 이용되는 경우도 있다.

하드웨어 오류로 인해서 인터럽트가 발생한다. 가장 긴급한 작업을 먼저 수행하기 위해서 인터럽트 우선순위 시스템을 사용하며 인터럽트는 시간에 민감하기 때문에 시스템 성능을 좋게 만들기 위해서 효율적인 인터럽트 처리가 필요하다.

## 저장장치 구조

**CPU**는 메모리에서만 명령을 적재할 수 있어 프로그램을 먼저 메모리에 적재해야 한다.

범용 컴퓨터는 프로그램 대부분을 **메인 메모리(RAM, memory)**라 불리는 재기록 가능한 메모리에서 가져오며 **DRAM(Dynamic Random-Access-Memory)**으로 구현된다. 

**CPU**는 특정 메모리 주소를 **CPU** 내부의 레지스터로 옮기는 **적재(load) 명령**과 레지스터의 내용을 메인 메모리로 옮기는 **저장(store)명령**으로 메인 메모리와 상호작용한다. 명시적인 load, store 명령 외에도 **CPU**는 프로그램 카운터에 저장된 위치부터 실행하기 위해서 메인 메모리에서 명령을 자동으로 load한다.

폰노이만 구조 시스템에서 실행되는 **전형적인 명령-실행 사이클**은 먼저 메모리로부터 명령을 인출하여 명령 레지스터(instruction register)에 저장한다. 이어 명령을 해독하고 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있다.

피연산자에 대해 명령을 실행한 후에 결과가 메모리에 다시 저장될 수 있다. 메모리 장치는 단순히 일련의 메모리 주소만을 인식한다. 메모리는 명령 카운터, 색인 간접 주소, 리터럴 주소가 어떻게 생성되었는지 전혀 알지 못하고 무엇인지(명령인지 데이터인지) 알지 못한다, 그러므로 우리는 메모리 주소가 프로그램에 의하여 어떻게 생성되었는지 무시할 수 있다. 우리는 단지 실행중인 프로그램에 의해 생성된 일련의 메모리 주소에만 흥미가 있다.

이상적으로는, 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다. **그러나 이는 다음 두가지 이유로 인해서 불가능하다.**

1. 메인 메로리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.
2. 메인 메모리는 전원이 공급되지 않으면  그 내용을 잃어버리는 휘발정 저장장치이다.

따라서 대부분의 컴퓨터 시스템은 보조저장장치를 제공한다. 보조저장장치는 대량의 데이터를 영구히 보존할 수 있어야 한다는 점이다.

대표적으로는 **하드 디스크 드라이브**와 **비휘발성 메모리(NVM)**가 존재한다.

다양한 저장장치 시스템은 **저장 용량 및 액세스 시간**에 따라서 계층 구조로 구성될 수 있다.

<div style="text-align: center;">
    <img src = "/image/posts/os/overview/storageHierarchy.png">
</div>

## 입출력 구조

운영체제는 시스템의 안정성과 성능을 중요시하기 때문에 코드의 상당 부분은 I/O 관리에 할애된다.

시스템은 범용 버스를 통해서 데이터를 교환한다. **인터럽트 구동 I/O 형태는 소량의 데이터를 이동하는데 좋지만 대량의 데이터를 이동하는데는 높은 오버헤드를 유발할 수 있다.** 

이 문제를 해결하기 위해서 **직접 메모리 액세스(DMA)**를 사용한다.

**장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅하여** CPU의 개입 없이 **메모리에 직접 접근**하여 데이터 블록을 전송한다.

**속도가 느린 장치처럼 한 바이트마다 인터럽트가 발생하는것이 아니라 블록 전송이 완료될 때마다 인터럽트가 발생한다.**

장치 컨트롤러가 전송 작업을 수행하는 동안 CPU는 다른 작업을 수행할 수 있다.

<div style="text-align: center;">
    <img src = "/image/posts/os/overview/io.png">
</div>


몇몇 고가의 시스템은 버스 대신에 스위치 구조를 사용하여 공유 버스를 사용하기 위해 경쟁하지 않고 다수의 구성요소가 다른 구성요소들과 동시에 통신하는것이 가능하다. 이 경우 DMA의 사용은 효과적이다.