---
title: "[OS] 운영체제 구조"
excerpt: "공룡책(Operating System Concept)의 2장 내용을 정리한 내용입니다."
categories:
    - OS
tags:
    - [OS, 시스템 콜, 모드 스위칭, System Call, Mode Switching]

toc: true
toc_sticky: true
toc_label: "목차"
toc_icon: "sticky-note"

date: 2024-02-14
last_modified_at: 2024-02-14
---

## 운영체제란 무엇인가?

### 핵심 논점

컴퓨터에 하드웨어만 달려있으면 사용자는 능숙하게 사용하기 힘들다. 따라서 사용자를 위해서 지원해주는 거대한 프로그램이 필요하다.

### 운영체제 정의

운영체제에 보편적인 정의는 없으며 필요에 따라서 형태가 매우 다르다.

운영체제는 컴퓨터 **하드웨어를 관리하는 소프트웨어**이다.

<div style="text-align: center;">
    <img src = "/image/posts/os/structure/os.jpeg" width = "50%">
</div>

운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중개자 역할을 한다.

**운영체제의 목적은 사용자가 프로그램을 편리하고 효율적으로 수행할 수 있는 환경을 제공하는 데 있다.**

## 운영체제 모드

컴퓨터에는 kernel이라는 항상 실행중인 하나의 프로그램이 존재한다.
kernel은 하드웨어 자원을 할당하고, 프로세스 제어, 메모리 제어 등 프로그램이 운영 체제에게 요구하는 시스템 콜을 수행하는 부분이며 운영체제의 핵심이다.

kernel을 기준으로, **사용자를 위한 application program**과 **하드웨어와 밀접한 로직이 실행되는 system programs**로 구분할 수 있다.

### Mode Switching

운영체제가 실행되는 시간은 **user mode**와 **kernel mode**로 나눌 수 있으며 이 두 모드간에 전환하는 것을 **mode switching**이라고 한다.

이렇게 2가지 모드를 구분한 이유는 **프로그램의 잘못된 동작으로 인해서 다른 프로그램에 영향을 주지 않게 만들기 위해서**이다.

<div style="text-align: center;">
    <img src = "/image/posts/os/structure/mode_switch.png" width = "80%">
</div>

- **user mode** : 사용자 인터페이스 부분이다. 하드웨어와 밀접한 동작을 처리하려면 시스템 콜을 통해서 kernel mode로 진입해야 한다.
- **kernel mode** : 하드웨어와 밀접하게 관련된 부분이다.

### 시스템 콜(system call)

모드 스위칭은 유저 인터페이스 코드를 실행하다가 커널에서 필요한 처리가 있는 경우 시스템 콜을 통해서 이루어진다.

시스템 콜이 호출되면 커널 모드로 전환 뒤 필요한 처리를 하고 나서 다시 유저 모드로 전환되어 남은 유저 프로그램 실행을 이어간다.

<div style="text-align: center;">
    <img src = "/image/posts/os/structure/systemcall.png" width = "80%">
</div>

시스템 콜은 동작마다 따로 준비되어 있다. 예를 들어, 파일로부터 내용 읽기를 수행하는 시스템 콜과, 프로세스를 만드는 시스템 콜이 따로 존재한다.

프로그램은 맞는 시스템 콜을 골라서 호출해야 한다. 대부분 운영체제들은 시스템 콜을 쉽게 사용할 수 있도록 시스템 콜 인터페이스를 지원한다.

시스템 콜의 종류는 대략 다음이 있다.

- 프로세스 제어 (fork, exit, wait)
- 파일 조작 (open, read, write, close)
- 장치 관리 (ioctl, read, write)
- 정보 유지 (getpid, alarm, sleep)
- 통신 (pipe, shm_open, mmap)
- 보호 (chmod, umask, chown)

시스템 콜이 처리되는 중에 오류가 발생할 수 있다. 이때는 적절하게 오류 발생을 알리고 해당 프로그램을 비정상 종료 처리해야 한다.

## 링커와 로더

소스 프로그램이 메모리에 올라가서 실행되기 전까지의 절차에 컴파일러, 링커, 로더가 차례대로 관여하게 된다.

- 컴파일러(compiler) : 소스 코드를 읽어들여서 메모리에 올릴 수 있는 오브젝트 파일을 만들어낸다.
- 링커(linker) : 이전 단계에서 만든 오브젝트 파일들과 라이브러리를 합쳐 실행 파일을 만들어낸다.
- 로더(loader) : 이전 단계에서 만든 실행 파일에 필요할 경우 동적 링킹 라이브러리(DLL : Dynamically Linking Library)를 연결하면서, 실행을 위해서 메모리에 로드한다.


<div style="text-align: center;">
    <img src = "/image/posts/os/structure/linkerLoader.png" width = "80%">
</div>

## 운영체제의 구조

운영체제가 취할 수 있는 구조에는 모놀리식 구조, 마이크로 커널, 계층형 구조 등이 있다.

- 모놀리식 구조(monolithic structure) : 쉽게 말해서 커널이 하나의 거대한 실행파일 그 자체인것이다. 시스템 구조 자체가 커널, 시스템 콜 인터페이스 , 유저 인터페이스를 모두 포함한 덩어리로 고정되어 있으며, 분리가 불가능하다.
    - 확장성이 떨어진다
    - 성능 면에서 이점이 많다.
- 마이크로커널(microKernel) : 커널에서 비교적 불필요한 기능들을 덜어내서 커널 규모를 최소화한 것이다. 덜어낸 기능들은 사용자 인터페이스 공간에서 각각 서버의 형태로 존재하여, 필요할 경우에 서로 통신하여 기능이 동작한다.
    - 확장성이 크게 증가한다.
    - 시스템 어느 한 곳에서 오류가 발생해도 나머지 부분에 영향을 미치지 않아 안정성이 있다.
    - 서비스간 통신에 발생하는 비용으로 성능 오버헤드가 크다.
- 계층형 구조 : 운영체제에 네트워크 OSI 7계층 구조처럼 계층 구조를 도입한다. 최하위가 하드웨어에 밀접하고 최상위는 사용자 인터페이스와 밀접하다.
    - 각 계층에서 어떤 역할을 전담해야 하는지 쉽지 않아 설계가 어렵다.
    - 구현과 디버깅이 간단하다.